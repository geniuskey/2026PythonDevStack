# 등급 시스템 안내

## 왜 등급이 필요한가?

파이썬 생태계에는 수많은 라이브러리가 있습니다. 모두 나름의 가치가 있지만, **"지금 새 프로젝트를 시작한다면?"** 이라는 질문 앞에서는 우선순위가 달라집니다.

이 책의 등급 시스템은:

- ✅ **현재 시점의 추천도**를 명확히 합니다
- ✅ **선택의 근거**를 제공합니다
- ✅ **시간을 절약**해줍니다

---

## 등급의 종류

### ⭐ 2026 추천

> **지금 새 프로젝트를 시작한다면 이것을 선택하세요**

#### 의미
- 2026년 현재 **가장 권장되는** 선택
- 커뮤니티의 주류 방향
- 현대적 파이썬 패턴을 따름
- 활발한 유지보수와 발전

#### 기준
1. **커뮤니티 momentum**: 다운로드 증가 추세
2. **현대성**: 최신 Python 기능 활용 (type hints, async 등)
3. **성숙도**: 프로덕션 검증됨
4. **생태계 통합**: 다른 현대 도구들과 잘 어울림
5. **유지보수**: 활발한 개발과 빠른 이슈 대응

#### 예시

| 분야 | ⭐ 2026 추천 | 이유 |
|------|-------------|------|
| 패키지 관리 | `uv` | 10-100배 빠름, Rust 기반, pyproject.toml 완벽 지원 |
| 린팅 | `ruff` | 50배 빠름, 통합 도구, flake8+black+isort 대체 |
| 웹 API | `FastAPI` | 비동기 기본, 자동 문서화, Pydantic 통합 |
| HTTP 클라이언트 | `httpx` | async 지원, requests 호환 API |
| 데이터 처리 | `polars` | pandas보다 10배 빠름, 병렬 처리 기본 |

#### 이 등급을 선택해야 하는 경우
- ✅ 새로운 프로젝트를 시작할 때
- ✅ 최신 베스트 프랙티스를 따르고 싶을 때
- ✅ 성능과 개발자 경험 모두 중요할 때
- ✅ 장기적인 유지보수를 고려할 때

---

### ⚠️ 레거시 / 유지보수용

> **기존 코드베이스에서는 유효하지만, 신규 채택은 신중히**

#### 의미
- 과거에는 표준이었으나, **더 나은 대안이 등장**함
- 기존 프로젝트에서는 계속 사용 가능
- 새 프로젝트에서는 재고 필요
- "나쁘다"는 의미가 **아닙니다**

#### 왜 이 등급이 되었나?
1. **성능**: 새로운 도구가 훨씬 빠름
2. **기능**: 현대적 기능 (async 등) 미지원
3. **편의성**: 더 간편한 대안 존재
4. **트렌드**: 커뮤니티가 다른 방향으로 이동

#### 예시

| 라이브러리 | 등급 | 이유 | 언제 여전히 OK? |
|-----------|------|------|---------------|
| `pipenv` | ⚠️ | uv, poetry가 훨씬 빠름 | 기존 프로젝트 |
| `flake8` | ⚠️ | ruff가 50배 빠르고 통합 | 설정 변경 어려울 때 |
| `Flask` | ⚠️ | FastAPI가 더 현대적 | 간단한 도구, Django 보조 |
| `requests` | ⚠️ | httpx가 async 지원 | 동기 코드면 여전히 최고 |
| `unittest` | ⚠️ | pytest가 훨씬 편함 | 표준 라이브러리만 써야 할 때 |

#### 이 등급일 때 선택 가이드

**유지해도 되는 경우:**
- ✅ 기존 코드베이스가 크고 안정적
- ✅ 팀이 이미 익숙함
- ✅ 마이그레이션 비용 > 개선 효과
- ✅ 특정 기능에 의존성 있음

**교체를 고려해야 하는 경우:**
- ⚠️ 성능이 병목
- ⚠️ 현대 기능(async 등) 필요
- ⚠️ 새 팀원 온보딩이 어려움
- ⚠️ 유지보수가 느리거나 중단

---

### 🔄 대체재 존재

> **동일 기능을 하는 더 나은 대안이 명확히 존재함**

#### 의미
- 이 라이브러리를 쓸 **특별한 이유가 없다면** 대안 고려
- 대안이 **압도적으로 우수**함
- 특수한 상황이 아니면 권장하지 않음

#### ⚠️와의 차이
- **⚠️**: "과거 표준이었음, 상황에 따라 OK"
- **🔄**: "굳이 이걸 선택할 이유가 있나요?"

#### 예시

| 라이브러리 | 등급 | 대안 | 대체 이유 |
|-----------|------|------|----------|
| `easy_install` | 🔄 | `pip`, `uv` | 사실상 폐기됨 |
| `nose` | 🔄 | `pytest` | 유지보수 중단 |
| `six` | 🔄 | Python 3 직접 사용 | Python 2 종료로 불필요 |
| `optparse` | 🔄 | `argparse`, `click` | 표준 라이브러리에서도 deprecated |

#### 예외적으로 선택해도 되는 경우
- 매우 오래된 레거시 시스템
- 특정 도구와의 강한 결합
- 교체 불가능한 특수 기능

대부분의 경우 **대안으로 마이그레이션 권장**

---

### 🧩 특정 상황 특화

> **일반적이지 않지만, 특정 상황에서는 최고의 선택**

#### 의미
- 범용 도구는 **아님**
- 특정 니치, 특수 목적, 특별한 요구사항에 최적화
- "좋다/나쁘다"가 아니라 **"맞다/안 맞다"**

#### 예시

| 라이브러리 | 등급 | 특화 상황 |
|-----------|------|----------|
| `dash` | 🧩 | 빠른 데이터 대시보드 (프로토타이핑) |
| `kivy` | 🧩 | 크로스 플랫폼 모바일 앱 (Python으로) |
| `hy` | 🧩 | Lisp 스타일로 Python 작성 |
| `Twisted` | 🧩 | 복잡한 네트워크 프로토콜 구현 |
| `gevent` | 🧩 | 동기 코드를 async처럼 실행 |

#### 언제 선택하나요?

**선택해야 하는 경우:**
- ✅ 정확히 이 상황에 해당함
- ✅ 범용 도구로는 해결 불가
- ✅ 특화 기능이 핵심 요구사항

**선택하지 말아야 하는 경우:**
- ❌ "흥미롭다"는 이유만으로
- ❌ 일반적인 용도로 사용
- ❌ 팀원이 모두 익숙해야 하는 상황

---

## 등급이 없는 경우

일부 라이브러리는 등급 표시가 없을 수 있습니다:

- **중립적 도구**: 상황에 따라 달라서 일괄 평가 어려움
- **너무 기초적**: 등급 매길 필요가 없음 (예: `os`, `sys`)
- **평가 보류**: 아직 검증 중이거나 새로 등장

---

## 등급 활용 전략

### 시나리오 1: 새 프로젝트 시작

```
1. ⭐ 마크부터 찾기
2. 프로젝트 요구사항과 매칭
3. ⭐ 중에서 선택
```

**빠른 의사결정 + 미래 안정성**

### 시나리오 2: 기존 코드 개선

```
1. 현재 사용 중인 도구 확인
2. ⚠️ 나 🔄 등급인가?
3. 대안 검토 (마이그레이션 비용 vs 효과)
```

**전략적 업그레이드**

### 시나리오 3: 학습 우선순위

```
1. ⭐ 도구들 위주로 학습
2. ⚠️는 개념 이해 수준으로
3. 🔄는 건너뛰어도 OK
4. 🧩는 필요할 때 찾아보기
```

**효율적인 학습 경로**

### 시나리오 4: 팀 표준 정하기

```
1. ⭐ 도구들로 기본 스택 구성
2. 팀 상황에 맞게 일부 ⚠️ 허용
3. 🔄는 원칙적으로 금지
4. 🧩는 사례별 승인
```

**일관성 있는 코드베이스**

---

## 등급의 한계

### 이 등급 시스템은 완벽하지 않습니다

1. **맥락 의존적**
   - "FastAPI가 ⭐"라도, 간단한 스크립트엔 과함
   - 상황에 따라 ⚠️가 더 나을 수 있음

2. **시간 의존적**
   - 2026년 1월 기준
   - 6개월 후면 달라질 수 있음

3. **주관적 요소**
   - 커뮤니티 트렌드 반영하지만
   - 절대적 진리는 아님

### 따라서

**등급을 참고하되, 최종 결정은 당신의 상황에서**

- 프로젝트 규모
- 팀 역량
- 성능 요구사항
- 마이그레이션 비용
- 유지보수 계획

을 고려하세요.

---

## 자주 묻는 질문

### Q1: ⚠️ 라이브러리는 쓰면 안 되나요?

**아닙니다.** ⚠️는 "나쁘다"가 아니라 "더 나은 대안이 있다"는 의미입니다.

- 기존 프로젝트: 계속 사용 OK
- 특정 상황: 여전히 최선일 수 있음
- 팀 역량: 익숙한 도구가 나을 수도

### Q2: 왜 `requests`가 ⚠️인가요? 여전히 많이 쓰이는데?

**맞습니다.** `requests`는 훌륭합니다. ⚠️인 이유:

- `httpx`가 async 지원하면서 requests와 거의 동일 API
- 2026년 새 코드는 점점 async 중심
- 동기 코드면 requests가 여전히 완벽함

**"상황에 따라 판단"이 핵심입니다.**

### Q3: ⭐ 도구만 배우면 되나요?

**아닙니다.** ⭐는 **우선순위**일 뿐:

- 개념 이해가 먼저 (HTTP, async, 테스트 등)
- ⚠️ 도구도 이해하면 좋음 (레거시 코드 작업 시)
- 🧩 도구는 필요할 때

**⭐는 "학습 시작점" 가이드입니다.**

### Q4: 등급은 어떻게 결정되나요?

다음을 종합 평가:

1. **다운로드 트렌드** (PyPI 통계)
2. **GitHub 활동** (커밋, 이슈, PR)
3. **커뮤니티 의견** (설문, 블로그, 컨퍼런스)
4. **성능 벤치마크** (공개 벤치마크 결과)
5. **기술적 현대성** (Python 3.12+ 기능 활용)
6. **생태계 통합도** (다른 도구와의 조합)

---

## 다음 단계

등급 시스템을 이해했다면, 이제 **2026 표준 스택**을 살펴볼 차례입니다.


---

**[← 이 책의 사용법](how-to-use.md)** | **[2026 표준 스택 개요 →](../02-modern-stack-2026/overview.md)**
